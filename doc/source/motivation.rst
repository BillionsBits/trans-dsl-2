动机
****

我们先从大家都熟悉的一个例子说起。

任何一家企业都需要招聘员工。描述的是某家企业制定的招聘流程图:

正如图中所描述的，流程的起始是收到应聘者投递的简历，而成功招聘到一个人的标志是：应聘者入职。

现在，我们用软件实现这个过程，其中，每个角色都是一个独立的系统或子系统，他们之间必须通过 **消息** 或 **事件** 进行通信。
如果，我们现在需要实现HR子系统，该如何做?

状态机
=====

**状态机** 是大多数基于消息的异步系统常用的实现方式。所以HR为一个应聘者设计了如图所示的状态机:

**状态模型** 和 **序列模型** 都能较好的反映一件事情的本质，但不同的是，**序列模型** 更加专注于目标系统的 **行为**，
而 **状态模型** 更关注被操作对象的 **状态迁移**。

但从实现的角度来看，如果你选择 **序列模型**，当然，你需要实现目标系统的 **行为**；而如果你选择 **状态模型**，那么除了需要管理 **状态机**之外，
你仍然需要处理目标系统的 **行为**。这就意味着，在实现层面，一旦选择 **状态模型**，就需要做许多额外的工作。

而这部分额外的工作绝不是轻松和愉快的——

首先，**状态机**应该管理每个状态下期望的激励，对于未期望的消息则应该忽略。
比如，在本例中，一个正处于 *“笔试中”* 状态的状态机，如果收到了一个 *“接受offer”* 消息，将是一件很奇怪的事情，所以，只能忽略它。
一个成熟的团队，对于状态机的管理往往会引入一个状态机引擎。一个典型的引擎需要程序员自己定义一张状态表，然后注册给引擎。

.. codeblock:: c++

    const StateTable states[] = {
    // ...
    { STATE_EXAM, { {EV_EXAM_RESULT, handleExamResult}}},
    { STATE_INTERVIEW,{ {EV_INTERVIEW_RESULT, handleInterviewResult}}}, // ...
    { STATE_OFFERED, { {EV_ONBOARD, handleOnBoard}
                           , {EV_TIMEOUT, handleTimedout} }}
    };
