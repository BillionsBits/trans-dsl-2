
`C++` 的编译时元编程，一则是对 **类型** 的操作，二则是对 **值** 的计算。

对于类型的操作，必然是没有副作用的（你或许可以修改值，但你永远无法修改一个类型）。

由于类型天然是 ``immutable`` 的，如果对于类型的演算是 **图灵完备** 的，那么其必然是 **函数式** 的。
而 `C++` 对于类型的演算，即 **泛型编程** ，从一开始就是 **图灵完备** 的。

为了理解函数式编程，我们用 `Haskell` 来做类比。比如，下面的代码定了一个函数：

.. code-block:: haskell

   f     :: Int -> Int -> Bool
   f a b =  (g a) || (h b)

其类型为：``a -> b -> c`` ，即给一个

先抛开函数模版，毕竟其主要作用是为了做数值计算（当然，其强大的类型推演能力，也是模版元编程的主要手段之一）。我们主要来看
类模版。

每一个类模版，都可以理解为是一个用来计算类型的函数，其输入为其模版参数，输出为模版实例化之后的类型。





当然，`C++` 的泛型，不仅仅可以进行类型演算，在 **数值** -> **类型** -> **类型的类型** 这三个级别上，都可以
进行演算，这也正是模版参数可以支持如下三个类别的原因：

- 非类型，即 **数值** (到了 `C++20` ，已经可以支持浮点数和对象）
- 类型
- 模版，即类型的类型


而值的演算，编译时也必然是没有副作用的，意味编译时不可能去修改运行时环境。虽然这并不意味着变量的 ``immutable`` 。
因为，任何一项计算，从计算开始，到计算结束，无论内部所使用的变量如何变化，只要计算结束后，整个环境没有任何变化。
则计算就是无副作用的。比如：

.. code-block:: c++

   int f(int a) {
      for(int i=0; i<100; i++) {
         a += i;
      }
      return a;
   }

这样一个函数，无论对输入参数 ``a`` ，还是局部变量 ``i`` ，都进行了变更。但整个函数依然是无副作用的，因而必然是 **引用透明** 的。
所以，谈到 **引用透明** ，就意味着 ``immutability`` ，是一种非常错误的结论。

对于值的演算在 `C++11` 之后，由于引入了 ``constexpr`` ，
并随着 `C++14` , `C++17` , `C++20` 对其约束的不断放宽，其编译时计算能力得到大幅度增强。



